/**
 * TurboDepot is a general purpose multi storage library (ORM, Logs, Users, Files, Objects)
 *
 * Website : -> http://www.turbodepot.org
 * License : -> Licensed under the Apache License, Version 2.0. You may not use this file except in compliance with the License.
 * License Url : -> http://www.apache.org/licenses/LICENSE-2.0
 * CopyRight : -> Copyright 2019 Edertone Advanded Solutions (08211 Castellar del VallÃ¨s, Barcelona). http://www.edertone.com
 */


import { StringUtils } from 'turbocommons-ts';
import { FilesManager } from './FilesManager';

declare let process: any;
declare function require(name: string): any;


/**
 * TerminalManager class
 *
 * @see constructor()
 */
export class TerminalManager {
    
    
    /**
     * If this value is set, all the executed terminal commands will be appended to it.
     * For example, if we defined baseCommand = 'copy' and we call exec('-a c:/tmp'), the effectively executed command
     * will be 'copy -a c:/tmp'
     */
    baseCommand = '';
    
    
    /**
     * A files manager instance used by this class
     */
    private filesManager: FilesManager;

    
    /**
     * Stores the NodeJs execSync instance
     */
    private execSync: any;
    
    
    /**
     * Class that helps with the process of interacting with command line applications and executions through the OS terminal
     * 
     * @return A TerminalManager instance
     */
    constructor() {

        this.execSync = require('child_process').execSync;
        
        this.filesManager = new FilesManager();
    }
    
    
    /**
     * Move the current terminal working directory to the specified path
     * 
     * @param path A full file system route to the location where the subsequent terminal commands must be executed
     * 
     * @return The new working directory full path
     */
    switchWorkDirTo(path: string) {
    
        process.chdir(path);
        
        return path;
    }
    
    
    /**
     * Create a new temporary directory on the temporary files location defined by the OS. If folder does not exist,
     * it will be created.
     * 
     * When the current application exits, the folder will be automatically deleted (if possible).
     * 
     * @param desiredName A name we want for the new directory to be created. If name is not available, a unique one
     *        (based on the provided desired name) will be generated automatically.
     * @param switchWorkDirToIt If set to true, when the new temporary folder is created, it will be defined as the
     *        current terminal working directory.
     * 
     * @return The full path to the newly created temporary directory
     */
    createTempDirectory(desiredName: string, switchWorkDirToIt = true) {
    
        let tmp = this.filesManager.createTempDirectory(desiredName);
        
        if(switchWorkDirToIt){
            
            this.switchWorkDirTo(tmp);
        }
        
        return tmp;
    }
    
    
    /**
     * Execute an arbitrary terminal cmd command on the currently active work directory and return all relevant data
     * 
     * @param command Some cmd operation to execute on the current working directory
     * @param liveOutput Set it to true to show the execution stdout in real time on the main console 
     * 
     * @return An object with two properties:
     *         - failed: False if the command finished successfully, true if any error happened
     *         - output: The full terminal output that was generated by the executed command
     */
    exec(command: string, liveOutput = false) {
    
        let output = '';
        let failed = false;        
        let finalCommand = command;
        
        if(!StringUtils.isEmpty(this.baseCommand)){
            
            finalCommand += ' ' + this.baseCommand;
        }
        
        // Aux method that tries to capture the command error
        let captureError = (e:any) => {
            
            if(e.stderr && !StringUtils.isEmpty(e.stderr.toString())){
                
                return e.stderr.toString();
            }
            
            if(e.stdout && !StringUtils.isEmpty(e.stdout.toString())){
                
                return e.stdout.toString();
            }
                
            return 'Unknown error executing ' + command + '\n' + e.toString();
        };
        
        if(liveOutput){
            
            try{
                
                output = this.execSync(command, {stdio:[0,1,2]});
                
            }catch(e){

                failed = true;
                output = captureError(e);
            }
            
        }else{
            
            try{
                
                output = this.execSync(finalCommand, {stdio : 'pipe'}).toString();
                
            }catch(e){
                
                failed = true;                
                output = captureError(e);
            }
        }
        
        return {
            failed: failed,
            output: output
        };
    }
}