<?php

/**
 * TurboDepot is a cross language ORM library that allows saving, listing and retrieving multiple kinds of objects
*
* Website : -> http://www.turbodepot.org
* License : -> Licensed under the Apache License, Version 2.0. You may not use this file except in compliance with the License.
* License Url : -> http://www.apache.org/licenses/LICENSE-2.0
* CopyRight : -> Copyright 2017 Edertone Advanded Solutions (Barcelona). http://www.edertone.com
*/

namespace org\turbodepot\src\main\php\managers;

use org\turbocommons\src\main\php\model\BaseStrictClass;


/**
 * Abstraction layer that is used to connect and operate with multiple database engines.
 * Each instance of this class is independant and works with a single database connection, so multiple instances
 * can be used to operate with different databases or connections at the same time.
 *
 * Common operations that can be performed by this class include: Connect to a database engine, execute queries,
 * count elements, list table columns and lot more.
 */
class DataBaseManager extends BaseStrictClass {


	/**
	 * Contains the last error that happened on the database (if any).
	 * Note: Any error that is raised by a db operation or query that is performed outside this class will not
	 * appear here.
	 */
	public $lastError = '';


	/**
	 * If any of the queries executed by this class exceeds the number of seconds specified here, a warning
	 * will be thrown. Setting this value to 0 will disable this feature.
	 */
	public $warnForSlowQueries = 0;


	/**
	 *
	 * The class will throw a PHP warning if the total accumulated query execution time exceeds the specified seconds (Set it to 0 to disable any warning).
	 */
	public $warnForSlowQueriesTotal = 0;


	/**
	 * Array containing all the queries (either succeeded or failed) that have been executed on this instance since it was created.
	 * Each array entry contains another array with the following values:<br>
	 * - query: the SQL query<br>
	 * - querySeconds: the time it took to execute it in seconds (with ms precision)<br>
	 * - querySecondsAccumulated: The total time spent on db queries plus the time of this query<br>
	 * - queryCount: The number of times the same exact query has been executed since the first connection<br>
	 */
	public $queryHistory = [];


	/**
	 * Stores the total accumulated time for all the executed queries since first connection
	 */
	public $accumulatedQueryTime = 0;


	/** Stores the database engine to which this class is currently being connected */
	private $_engine = '';


	/** Variable that stores the mysql database connection id so it can be used for all the operations */
	private $_mysqlConnectionId = null;


	/** Array that is used to chain the different transaction operations so multiple calls are taken into account */
	private $_transactionQueue = [];


	/**
	 * Initialize a mysql database connection with the specified parameters
	 *
	 * @param string $host Path to the mysql server (possible values: an ip, a hostname, 'localhost', etc ...)
	 * @param string $dataBaseName The name for the database to which we want to connect
	 * @param string $userName The database user we will use for the connection
	 * @param string $psw The database user password
	 *
	 * @return boolean True on success or false if connection was not possible
	 */
	public function connectMysql($host, $dataBaseName, $userName, $psw){

		$id = mysqli_connect($host, $userName, $psw, $dataBaseName);

		if(mysqli_connect_errno()){

			throw new Exception('Could not connect to MYSQL'.mysqli_connect_error(), E_USER_ERROR);
		}

		// Force MYSQL and PHP to speak each other in unicode  UTF8 format.
		if(!mysqli_query($id, "SET NAMES 'utf8'")){

			throw new Exception('Could not set connection encoding', E_USER_ERROR);
		}

		$this->_engine = 'mysql';
		$this->_mysqlConnectionId = $id;

		return true;
	}


	/**
	 * TODO
	 */
	public function connectPostgreSql($todo){

		// TODO
	}


    /**
     * Get the result for the specified SQL query as an associative array.
     *
     * @param string $query The SQL query to execute
     *
     * @return The result of the query as an associative array or null if there's a query error.
     */
    public function queryToArray($query){

    	$queryStart = microtime(true);

    	$a = [];

    	switch($this->_engine){

			case 'mysql':
				$result = mysqli_query($this->_mysqlConnectionId, $query);

				if(!$result){

					$this->lastError = mysqli_error($this->_mysqlConnectionId);
					return null;
				}

				while($line = mysqli_fetch_assoc($result)){

					array_push($a, $line);
				}
				break;
		}

		$this->_addQueryHistoryValue($query, $queryStart);

    	return $a;
    }


	/**
	 * Gets the auto increment id value that's been generated by the last executed insert query
	 *
	 * @return The id value
	 */
	public function getLastInsertId(){

		switch($this->_engine){

			case 'mysql':
				return mysqli_insert_id($this->_mysqlConnectionId);
				break;
		}
	}


	/**
	 * Gets all the values for one field in the specified table from the database,
	 * as a String separated with comas. Note that this is usefull when not many results are expected,
	 * as it probably will overflow the resultin string.
	 *
	 * @param string $field table field
	 * @param string $table specified table
	 *
	 * @return values TODO
	 */
	public function getAllFieldValuesString($field, $table){

		// TODO - tornem un array. Reescriure funcio!

		$result = $this->queryToArray('SELECT '.$field.' FROM '.$table);

		if($result === null){

			$this->lastError = mysqli_error($this->_mysqlConnectionId);
			return null;
		}

		$returndata = '';

		if (!$result){

			return '';
		}

		// EMPTY result
		if (mysqli_num_rows($result) == 0){

			return '';
		}

    	$line = $this->getNextLine ($result);
    	$returndata = $line[$field];

		while ($line = $this->getNextLine ($result)){

			$returndata = $returndata.','.$line[$field];
		}

		return $returndata;
	}


	/**
	 * Gets the maximum value for a specified field on the specified table.
	 *
	 * @param string $field table field
	 * @param string $table specified table
	 * @param string $wheresection restriction
	 *
	 * @return the maxium value
	 */
	public function getFieldMaxValue($field, $table, $wheresection = ''){

		$result = $this->query('SELECT CAST('.$field.' AS SIGNED) AS '.$field.' FROM '.$table.' '.$wheresection.' ORDER BY '.$field.' DESC');

		// ERROR in query
		if(!$result){

			$this->lastError = mysqli_error($this->_mysqlConnectionId);
			return -1;
		}

		// EMPTY result
		if (mysqli_num_rows($result) == 0){

			return 0;
		}

    	$line = $this->getNextLine($result);
    	return $line[$field];

	}


	/**
	 * Gives an array with all the names for the columns of the selected table, sorted as they are defined in the table.
	 *
	 * @param string $tablename the name of the table
	 *
	 * @return boolean|array The list of column names or false if an error happens
	 */
	public function getTableColumnNames($tablename){

		$query = 'SHOW COLUMNS FROM '.$tablename;

		$queryStart = microtime(true);

		$result = mysqli_query($this->_mysqlConnectionId, $query);

		$this->_addQueryHistoryValue($query, $queryStart);

		if(!$result){

			$this->lastError = mysqli_error($this->_mysqlConnectionId);
			return false;
		}

		$returnarray = array();

 		if (mysqli_num_rows($result) > 0){

    		while ($row = mysqli_fetch_assoc($result)){

    			array_push($returnarray, $row['Field']);
    		}

         	return $returnarray;
 		}

        return false;
	}


	/**
	 * Used to create a new row for a table.
	 *
	 * @param string $table the table name
	 * @param string $values the values to add
	 *
	 * @return boolean
	 */
	public function tableInsert($table, $values){

		$fields = $this->getTableColumnNames($table);
		$fieldnum = count($fields);
		$valuesnum = count ($values);
		$i = 1;

		// Add all the fields to the insert sentence
		$sql = 'INSERT INTO '.$table.' ('.implode(',',$fields).') VALUES (';

		// We use array_shift to avoid problems with arrays that use only key values and do not have indexes, like $_GET
		$tempres = array_shift($values);
		if (is_string($tempres)){

			$sql .= "'".$tempres."'";

		}else{

			$sql .= $tempres;
		}

		// Check if the received value is a string or not. (Maybe not so much usefull, but...)
		while ($i<$valuesnum){

			$tempres = array_shift($values);

			if (is_string($tempres)){

				$sql .= ",'".$tempres."'";

			}else{

				$sql .= ','.$tempres;
			}
			$i++;
		}

		$sql .= ')';

		$result = $this->queryToArray($sql);

		if($result === null){

			$this->lastError = mysqli_error($this->_mysqlConnectionId);
			return false;
		}

		return true;
	}


	/**
	 * Used to update the values for a specific row in a table. The row to modify is defined
	 * by it's primary key. All the other values must be passed in the same order as they
	 * are declared in the table.
	 *
	 *@param string $table The name for the table to update
	 *@param array $primarykey the value for the key for the row to update. It is an array, as the key can be formed by more than one field.
	 * 			IMPORTANT: The table field structure must begin always with the primary key values, then the foreign and finally the different values.
	 *@param string $values All the different values for the table data. THESE MUST NOT INCLUDE THE PRIMARY KEY VALUES!!
	 *
	 *@return boolean
	 *
	 */
	public function tableUpdate($table, $primarykey, $values){

		// The primary key data must be in the form of an array
		if(!is_array($primarykey)){

			$primarykey = array($primarykey);
		}

		$fields = $this->getTableColumnNames($table);
		$fieldnum = count($fields);
		$primarykeynum = count($primarykey);
		$valuesnum = count ($values);

		// Add all the fields to the update sentence
		// We use array_shift to avoid problems with arrays that use only key values and do not have indexes, like $_GET
		$sql = 'UPDATE '.$table.' SET ';
		$tempres = array_shift($values);

		if (is_string($tempres)){

			$sql .= $fields[$primarykeynum]." = '".$tempres."'";

		}else{

			$sql .= $fields[$primarykeynum].' = '.$tempres;
		}

		// Check if the received value is a string or not. (Maybe not so much usefull, but...)
		$i = 1;
		while ($i<$valuesnum){
			$tempres = array_shift($values);
			if (is_string($tempres))
				$sql .= ','.$fields[$i+$primarykeynum]."= '".$tempres."'";
			else
				$sql .= ','.$fields[$i+$primarykeynum].'= '.$tempres;
			$i++;
		}

		// Now is time to add the WHERE condition from the primary key
		$i = 1;
		$sql .= ' WHERE '.$fields[0]." = '".$primarykey[0]."'";
		while ($i<$primarykeynum){
			$i++;
			if (is_string($primarykey[$i]))
				$sql .= ' AND '.$fields[$i]." = '".$primarykey[$i]."'";
			else
				$sql .= ' AND '.$fields[$i].' = '.$primarykey[$i];
		}

		if($this->queryToArray($sql) === null){

			$this->lastError = mysqli_error($this->_mysqlConnectionId);
			return false;
		}

		return true;
	}


	/**
	 * Get the total amount of rows by applying the COUNT method on the specified table primary key.
	 *
	 * @param int $primaryKey The query field that contains the table primary key, that will be used to count the items
	 * @param string $from    The sql FORM part that will be used on the query
	 * @param string $where	  The sql WHERE part that will be used on the query (optional)
	 *
	 * @return integer The total number of items
	 */
	public function countByPrimaryKey($primaryKey, $from, $where = ''){

		$line = $this->getNextLine($this->query('SELECT COUNT('.$primaryKey.') as items '.$from.' '.$where));

		if($line == null){

			return 0;

		}else{

			return $line['items'];
		}
	}


	/**
	 * Count the total number of rows that a SQL query will generate
	 *
	 * @param string $query the SQL Query that we want to count
	 *
	 * @return integer The total count of rows that the query will generate
	 */
	public function countByQuery($query){

		$result = $this->query($query);

		if(!$result){

			$this->lastError = mysqli_error($this->_mysqlConnectionId);
			return false;
		}

		return mysqli_num_rows($result);
	}


	/**
	 * Detect if the specified table exists on database
	 *
	 * @param string $tablename the name of the table
	 *
	 * @return boolean result
	 */
	public function tableExists($tablename) {

		switch($this->_engine){

			case 'mysql':
				return (mysqli_num_rows(mysqli_query($this->_mysqlConnectionId, "SHOW TABLES LIKE '".$tablename."'"))==1);
				break;
		}
	}


	/**
	 * Start a database transaction
	 * TODO explicar com funciona el mecanisme de encadenament de transaccions i dir que es independent del motor de bd
	 * @return void
	 */
	public function transactionBegin(){

		if(count($this->_transactionQueue) <= 0){

			$this->query('START TRANSACTION');
		}

		// We must chain each transaction begin call so only the first time is executed
		array_push($this->_transactionQueue, '1');

	}


	/**
	 * Rollback a database transaction
	 *
	 * @return void
	 */
	public function transactionRollback(){

		// reset the transaction queue
		$this->_transactionQueue = [];

		$this->query('ROLLBACK');

	}


	/**
	 * Commit a database transaction
	 *
	 * @return void
	 */
	public function transactionCommit(){

		// We remove an element from the transaction queue and execute only if array is empty.
		array_shift($this->_transactionQueue);

		if(count($this->_transactionQueue) <= 0){

			$this->query('COMMIT');
		}

	}


	/**
	 * Close the database conection
	 *
	 * @return void
	 */
	public function disconnect() {

		// TODO:

	}



	/**
	 * Store a new entry to the query history array
	 *
	 * @param string $query The SQL query to store
	 * @param string $queryStart The microtime when the query started. This method will calculate the total time
	 *
	 * @return void
	 */
	private function _addQueryHistoryValue($query, $queryStart){

		// Some queries are not useful
		if($query == 'START TRANSACTION' || $query == 'ROLLBACK' || $query == 'COMMIT'){

			return;
		}

		$queryEnd = microtime(true);

		$querySeconds = round($queryEnd - $queryStart, 4);

		// Calculate the accumulated time for all the queries since start to now
		$this->$accumulatedQueryTime += $querySeconds;

		// Check if we must generate a warning due to slow query times
		if($this->warnForSlowQueries > 0 && $querySeconds > $this->warnForSlowQueries){

			trigger_error('Warning: The following SQL query required more than '.$this->warnForSlowQueries.' seconds to execute: '.$query, E_USER_WARNING);
		}

		// Check if we must generate a warning due to slow query total times
		if($this->warnForSlowQueriesTotal > 0 && $this->$accumulatedQueryTime > $this->warnForSlowQueriesTotal){

			trigger_error('Warning: The SQL queries total execution time has exceeded '.$this->warnForSlowQueriesTotal.' seconds', E_USER_WARNING);
		}

		// Check that the current query does not already exist on history
		for($i = 0; $i<$queryHistoryCount; $i++){

			if($this->queryHistory[$i]['query'] == $query){

				$this->queryHistory[$i]['querySeconds'] = ($this->queryHistory[$i]['querySeconds'] + $querySeconds) / 2;
				$this->queryHistory[$i]['querySecondsAccumulated'] = $accumulatedTime;
				$this->queryHistory[$i]['queryCount'] += 1;

				return;
			}
		}

		// Reaching here means this is the first time the query is executed, so we will store it
		array_push($this->queryHistory, array('query' => $query, 'querySeconds' => $querySeconds, 'querySecondsAccumulated' => $accumulatedTime, 'queryCount' => 1));
	}
}

?>
